<!--
Functions are values ; types of values : numbers, strings , booleans

We can also save fns inside variables, they are values
Hoisting is calling a fn before the fn is created in a code , it doesnt work when a fn is saved in a vriable

As long as there is a way to access the fn without using the name , we delete it and use an anonymous fn

Because functions are values, we can also pass a fn into a fn , the fn being passed in is called a Callback fn 

Anything we can do with a value , we can also do w a function 

setTimeOut() allows us to run a fn in the future 

Asynchronous code : the computer won't wait for a line to finish before going to the next line
Synchronous code : the computer will wait for one line to finish before going to the next line 

Arrow Function ~ mostly work the same as regular functions
Brackets are optional for just one param , we can also put all on one line and remove curly B x return statement
Use arrow fn when we are passing a fn into another fn , so is easier to differentiate

Regular functions is good because is easier to read and also good for hoisting 

addeventListener(); 
Instead of onclick , we can use ~ addeventListener(); 
Every html has a method called .addEVentListener(); - lets us run some code when we interact w the element 
.addEVentListener() ~ has two parameters ~ (event, a fn we want to run);
1. we can use multiple event listeners for an event 
2. we can remove event listener using .removeEventListener() ~ (event , same fn you want to remove )

Best practise is that you use event listener instead of onclick attribute 

Array methods we learnt : forEach , filter , map 

.filter():
- creates a new array[]
- return true >> put value in array and vv

.map() :
- Creates a new array []
- Whatever we return => added to new array 
- transforms an array into another array based on the return value

Closure:
- if a function has access to a value 
- it will always have access to that value 
- value gets packaged together(enclosed) with the function ie index 

If you want to avoid redundancy (DRY), make the code a fn 
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Function</title>
  </head>
  <body>
    <button onclick="" class="js-button">Click</button>
    <script>
      const buttonElement = document.querySelector(".js-button");

      const eventListener = () => {
        console.log("click");
      };
      buttonElement.addEventListener("click", eventListener);

      buttonElement.removeEventListener("click", eventListener);
      buttonElement.addEventListener("click", () => {
        console.log("click2");
      });

      function greeting() {
        console.log("Hello");
      }
      greeting();
      //Shortcut for above
      var greeting = function () {
        console.log("Hello");
      };

      const num = 2;
      const function1 = function greeting() {
        console.log("Hey there");
      };
      console.log(function1);
      console.log(typeof function1);
      function1();

      //Function without a name
      const function11 = function () {
        console.log("Hey there");
      };

      const object1 = {
        num: 2,
        fun: function greeting() {
          console.log("Hello3");
        },
      };
      object1.fun();

      function display(param) {
        console.log(param);
      }
      display(2);

      function run(param) {
        param(); // if a fn is passed in
      }

      run(function () {
        console.log("hello4");
      });

      //takes 2 parameter , the first one is a parameter we want to run in the future
      // fn(value) inside a fn , how long to wait before running
      // setTimeOut - only part that is asynchronous, it doesnt block our code
      setTimeout(function () {
        console.log("timeout");
      }, 3000);
      console.log("next line");

      // It will keep running in the future
      setInterval(function () {
        console.log("interval");
      }, 3000);
      console.log("next line2");

      // .forEach() is the preferred way to loop through an array, instead of using continue , we can only use return , and if we need to use break, just use a normal for-loop
      ["make dinner", "wash dishes", "watch youtube"].forEach(
        (value, index) => {
          if (value === "wash dishes") {
            return;
          }
          console.log(index);
          console.log(value);
        }
      );

      const regularFunction = function (param1, param2) {
        console.log("regular-functions");
        return 5;
      };

      const arrowFunction = (param1, param2) => {
        console.log("arrow-functions");
        return 5;
      };
      regularFunction();
      arrowFunction();

      //
      const oneParam = (param) => {
        console.log(param + 1);
      };
      oneParam(77);

      const oneLine = () => 2 + 3;
      console.log(oneLine());

      const object2 = {
        method: () => {},
        //shorthand method is better than arrow fns
        method() {},
      };

      console.log(
        [1, -3, 5].filter((value, index) => {
          // if (value >= 0) {
          //   return true;
          // } else {
          //   return false;
          // }
          return value >= 0;
        })
      );

      console.log(
        [1, 1, 3].map((value, index) => {
          return value * 2;
        })
      );

      console.log([1, 1, 3].map((value) => value * 2));
    </script>
  </body>
</html>
