## Backend, Callbacks, Promises, and Async Wait

ğŸŒ What does HTTP do?
HTTP stands for HyperText Transfer Protocol. Itâ€™s the communication system used between your browser (client) and a web server.

ğŸš€ What HTTP does:
ğŸ“¤ Sends requests:
When you visit a website, your browser uses HTTP to send a request to the server (usually a GET request).

ğŸ“¥ Gets responses:
The server processes that request and sends back a response â€” like HTML, JSON, images, or other data.

ğŸ“¦ Delivers content:
HTTP handles how web pages, images, and data get delivered to your screen.

ğŸ§  Simple analogy:
HTTP is like a waiter ğŸ§‘â€ğŸ³ at a restaurant.
You (the browser) tell the waiter what you want (send a request),
the kitchen (server) prepares it,
and the waiter brings it back to you (response).

HTTP methods are GET, POST, PUT, DELETE!
========================================================
To send HTTP message : we are going to use a class called XMLHTTPRequest (Built in class)

âœ… The built-in class XMLHttpRequest in JavaScript handles both:

ğŸ“¨ Request

- It sends an HTTP request from your JavaScript code to a server.
- You can choose the method (GET, POST, etc.), set headers, and send data if needed.

ğŸ“© Response
It also receives the response from the server and gives you access to:

Response status (xhr.status)
Response text/data (xhr.responseText)
Headers, etc.

ğŸ” Summary:
XMLHttpRequest is used to send requests and receive responses between the browser and a server without reloading the page.

Example:
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://example.com/api/data");

xhr.onload = function () {
console.log(xhr.responseText); // This is the response
};

xhr.send(); // This sends the request
So yes â€” it does both request and response handling.
=====================================================
URL - Uniform Resource Locator : like an address, but for the internet, helps us locate another computer on the internet
https://amazon.com
http - means we are using http to communicate with this computer , s means it is secured version of http
amazon.com - domain name : like an address, points to another computer on the internet

This code creates and sends an HTTP GET request to https://supersimplebackend.dev using XMLHttpRequest. Here's what's happening step by step:
new XMLHttpRequest() â€“ creates a new request object.
xhr.open("GET", url) â€“ sets the method and destination.
xhr.send() â€“ sends the request to the server.
ğŸ’¡ It initiates communication with a backend server to request data.

In the network tab, messages would only appear here after we open the console - refresh the page

=====================================================
ğŸ’¬ Request â¡ï¸ Response Cycle (Client â†”ï¸ Server)

ğŸ§‘â€ğŸ’» (Frontend/Client)
|
| ğŸŒ Request ğŸ‘‰ (e.g. GET, POST)
| ------------------------------->
| Message to Server
|
| ğŸ–¥ï¸ (Backend/Server)
| Receives request ğŸ“©
| Processes it âš™ï¸
| Sends back data ğŸ“¤
|
| ğŸ‘ˆ Response ğŸ’¡ (e.g. JSON, HTML)
| <-------------------------------
| Message from Server
v
ğŸ§‘â€ğŸ’» (Frontend gets the data & displays it)

âœ… Answer to Your Question:
Is it automatic to get a response back when we send a request?
ğŸ”¸ Yes, every HTTP request expects a response from the backend â€” even if it's just a confirmation like 200 OK, or an error like 404 Not Found.

However:
If the server crashes, or
Thereâ€™s a network issue,
Then the response might fail or not arrive, and youâ€™ll need error handling (onerror, try-catch, etc.) to deal with it.

Summary:
- Request = You ask for something (e.g. data)
- Response = Server replies (with what you asked or an error)
- It's like a conversation: every question (request) should get an answer (response). âœ…

   Asynchronous code allows a program to start a task (like fetching data from a server) without waiting for it to finish before moving on to the next line. Instead of blocking the whole program, it continues running other code and handles the result later when it's ready (using callbacks, promises, or async/await).

ğŸ” Simple Example:
console.log("1");
setTimeout(() => {
console.log("2"); // Runs later
}, 1000);
console.log("3");

Output :
1
3
2

# We send the request, wait for the reponse and save the response in our code
- A backend only supports a certain set of URL paths
  404 - Status code
- ğŸ” The backend can respond with various data formats â€” such as text, JSON, HTML, or even ğŸ–¼ï¸ images.
  ğŸ§¾ When we receive a JSON response, it's actually just text (a JSON-formatted string).
  ğŸ”„ We use JSON.parse() to convert that text into a ğŸ§  JavaScript object that we can work with in our code.
  ğŸŒ This enables seamless transmission of JavaScript objects between the frontend and the backend over the internet.

  ğŸŒ When you type a URL into the browser and hit enter, the browser automatically sends an ğŸ“¤ HTTP GET request to the server.
  ğŸ§­ In simple terms: Typing a URL + hitting enter = making a GET request.

- Depending on the type of response, the browser can respond in a more useful way

- In JS, fns are values aand we can use it as a parameter

An API (Application Programming Interface) is a set of rules ğŸ› ï¸ that lets two software systems talk to each other.

ğŸ§¾ Real-World Analogy:
Imagine you're at a restaurant ğŸ½ï¸:
You = the frontend (e.g., your website or app)
Waiter = the API ğŸ‘¨â€ğŸ³
Kitchen = the backend (server/database)

ğŸ—£ï¸ You tell the waiter (API):
"I want a burger ğŸ” and fries ğŸŸ"

The waiter (API) gives the message to the kitchen (backend), waits for it to cook the food (process), and brings it back to you.

ğŸ§  In Tech Terms:
- Your frontend sends a request using the API.
- The API delivers it to the backend.
- The backend processes it and sends data (like JSON) back.
- Your app uses that data to update the screen.

ğŸ¯ These rules define:
ğŸ”— The URL to use
Example:
https://api.shop.com/products â€“ this is where you ask for products.

ğŸ“¬ The method to use
Example:
GET = retrieve data
POST = send data
DELETE = remove something

ğŸ§¾ The format of the request
Often needs:
Headers (e.g. Content-Type: application/json)
Body (e.g. { "name": "Shoes" } in JSON)

ğŸ“¤ What response you'll get
The API promises to return a certain data structure (like JSON).

ğŸ§  In short:
The API rules tell your app:
â€œIf you send me a request like this, Iâ€™ll respond like that.â€

==========================================================================
ğŸ§  What is a Callback Function?
A callback function is a function that you pass as an argument to another function, and it's called later â€” usually after something happens (like data loading, a button click, etc.).

Itâ€™s called â€œcallbackâ€ because the code youâ€™re giving it will be called back when the time is right.

ğŸ” What is an Anonymous Function?
An anonymous function is a function that:
âœ… Has no name
âœ… Is often used as a callback
âœ… Is written directly where it's needed, instead of defining it somewhere else

ğŸ”„ Anonymous function as a callback:
setTimeout(function() {
console.log("Hello after 2 seconds");
}, 2000);

This is an anonymous function â€” no name is given.
But you can't use it alone â€” it must be passed into something, like another function (setTimeout()).

You passed an anonymous function to setTimeout.
It runs after 2 seconds.
No need to name the function â€” itâ€™s used only once.

ğŸ”¼ Arrow function version (also anonymous):
setTimeout(() => {
console.log("Hello after 2 seconds");
}, 2000);

âœ… This is an anonymous arrow function â€” still no name, just a shorter way to write it.

ğŸš€ Using a backend in our project:
ğŸ“¤ We send a request to the server,
â³ use a callback to wait for the response,
âœ… and once the response arrives, we run the rest of our ğŸ§  logic/code.

ğŸŒŸ What is a Promise?
A Promise is like a promise in real life â€” it represents an action that will finish in the future, either with:

âœ… Success (the promise is fulfilled), or
âŒ Failure (the promise is rejected)

ğŸ§© Visual Analogy: Ordering a Package Online ğŸ“¦

- Step 1: You order something online ğŸ›’
  You get a promise: â€œYour package will arrive soon.â€
  Right now, the package is pending â€” you donâ€™t have it yet.

- Step 2: Waiting for delivery â³
  While you wait, you can keep doing other things. The promise is still pending.

- Step 3: Package arrives or fails to arrive ğŸšš
  Success (fulfilled): The package arrives at your door. ğŸ‰
  Failure (rejected): The package gets lost or delayed. âŒ

ğŸ§‘â€ğŸ’» How it looks in code:
let packagePromise = new Promise((resolve, reject) => 
{
// Simulate waiting for package delivery (async)
setTimeout(() => {
let delivered = true; // or false for failure

    if (delivered) {
      resolve("Package received! ğŸ‰");
    } else {
      reject("Package lost! âŒ");
    }
}, 3000);
});

ğŸ”„ Handling the Promise:
packagePromise
.then((message) => {
console.log("Success:", message); // Runs if resolve() is called
})
.catch((error) => {
console.log("Error:", error); // Runs if reject() is called
})

âš¡ Visual Flowchart:
[Start]
â†“
[Promise Created] â€”â€”â€” Pending (waiting)
â†“
/ \
Resolve Reject
â†“ â†“
Success Failure
(then) (catch)

ğŸ§  Summary:
Promise = a placeholder for a value that will arrive later
.then() runs when the promise is fulfilled (success)
.catch() runs when the promise is rejected (error)
While waiting, your program can do other things (non-blocking!)

ğŸ†• new Promise(...)
ğŸ› ï¸ This is the constructor that creates a Promise object.

ğŸ” The function you pass inside:
(resolve) => { ... }
ğŸ§  This is called the executor function.
âš¡ JavaScript automatically runs this function as soon as the Promise is created.

ğŸ“¥ The executor function receives two special functions as parameters:
âœ… resolve â†’ Call this to mark the Promise as fulfilled (success)
âŒ reject â†’ Call this to mark the Promise as rejected (error)
ğŸ“ (In your example, only resolve is used.)

ğŸ§© Inside your executor:
loadProducts(() => {
resolve(); âœ…
});
ğŸ“¦ You call loadProducts(...) to start loading data.
ğŸ•’ When it finishes, it calls resolve().
ğŸ“£ This tells JavaScript:
âœ… â€œThe Promise is done and was successful!â€

ğŸ§  Whatâ€™s the Goal?
Both callbacks and promises are ways to handle asynchronous code â€” things that take time, like loading data or waiting for user input.

But they work differently.
âš¡ Quick Comparison:
Feature	Callback	- Promise
ğŸ”„      Style	  -  Function passed as argument	Object returned immediately
ğŸ“¦      Value handling -	Manually inside callback - Automatically with .then()
âŒ Error handling	Must be handled manually - Built-in with .catch()
ğŸ¤¯ Downsides	Callback Hell ğŸ˜© - 	Cleaner, avoids nesting
âœ… Modern usage	Old-style (still works) -	Preferred in modern JS âœ…

- Promises help keep our code flat and avoid nesting:
allows us to pass a value, we can run multiple promises at the same time using Promise.all()

- Problem with promises is that it creates a lot of extra code (new promises >> resolve >> .then) except we return the promise as a function 

- Fetch also make a request to the backend using a promise and not a callback 
- Fetch is a better way to use http request because it uses promises directly 

ğŸ§  What is a Promise?
A Promise is like a ğŸ“¦ box that JavaScript gives you to say:

"â³ Iâ€™ll go get something (like data from the server) â€” when Iâ€™m done, Iâ€™ll let you know with either âœ… success or âŒ failure."

ğŸ›  What does fetch(...) do?
fetch("https://supersimplebackend.dev/greeting")
ğŸ”§ Makes a network request (GET by default)

ğŸš€ Starts it immediately
ğŸ Returns a Promise â€” which will eventually:
âœ… resolve with a Response object if the request succeeds
âŒ reject if something goes wrong (like network error)


ğŸ”„ async/await â€” A Better Way to Handle Asynchronous Code
âœ… Definition:
âœ¨ async/await is a cleaner and more readable way to work with asynchronous code.
ğŸª„ It's basically a shortcut for using Promises, without all the .then() and .catch() chaining.

ğŸ§  Think of it like this:
Feature	             Description
ğŸ§© async	          Tells JavaScript: "This function will use await."
â³ await	           "Pause here until the Promise is done."
âœ… Cleaner Code	   Looks like regular synchronous code âœ¨
ğŸ“¦ Result	          You can use the result as if itâ€™s already there

- We can only use await when we're inside an async function, we use async so we can make our code cleaner 
- async await can only be used with promises , it doesnt do anything with a callback 

- When working with async codes , best practise is to use async await over promises and callbacks because they are much cleaner

Place your order button - is going to turn the cart into an order

ğŸ“¤ When a browser sends a request to a backend:
ğŸ“ Headers carry metadata (e.g. Content-Type, Authorization) to describe the request.
ğŸ“¦ Payload (also called the body) contains the actual data being sent (like form inputs or JSON).
ğŸ” Preview shows a sneak peek of the returned data (like a snippet of a JSON or HTML response).
ğŸ“¥ Response is what the backend sends back â€” includes status, headers, and the actual data.
ğŸ¯ Initiator is what triggered the request â€” such as a script, a user action, or a page load.

ğŸ•¸ï¸ Backend Request Timeline (with Symbols)
ğŸ“¦ FRONTEND (Browser / App)
â”‚
â”‚   ğŸ¯ 1. Initiator
â”‚   â””â”€â”€ Who or what triggered the request?
â”‚        â†ªï¸ e.g. Button click, fetch(), page load, script
â”‚
â”‚   ğŸ“ 2. Request Headers
â”‚   â””â”€â”€ Metadata about the request
â”‚        â†ªï¸ Content-Type: application/json
â”‚        â†ªï¸ Authorization: Bearer token123
â”‚
â”‚   ğŸ“¦ 3. Payload (Body)
â”‚   â””â”€â”€ Optional: Actual data being sent to the backend
â”‚        â†ªï¸ e.g. { "email": "test@example.com", "password": "1234" }
â”‚
â–¼
ğŸŒ NETWORK
â–¼
ğŸ“¥ BACKEND (Server/API)
â”‚
â”‚   âœ… Receives request
â”‚   âœ… Reads headers and payload
â”‚   âœ… Processes it (e.g. DB lookup, validation)
â”‚   âœ… Sends back a response
â”‚
â–¼
ğŸ“¦ RESPONSE
â”‚
â”‚   ğŸ“¥ 4. Response (Status + Body)
â”‚   â””â”€â”€ What the server returns
â”‚        â†ªï¸ Status: 200 OK / 401 Unauthorized
â”‚        â†ªï¸ Body: { "success": true, "user": {...} }
â”‚
â”‚   ğŸ” 5. Preview
â”‚   â””â”€â”€ Browser displays a snippet of the response
â”‚        â†ªï¸ Great for inspecting JSON, HTML, etc.
â”‚
âœ… Response handled in frontend (rendered or logged)

ğŸŒ Tracking Page with URL Parameters (Explained with Symbols)

ğŸ§­ Goal: We want each tracking page to be different depending on the order and the product â€” so we know which product to show or track.

ğŸ’¡ Solution: Use URL Parameters
ğŸ”‘ A URL parameter is extra info we attach to the end of a URL to send data.
â“ The ? symbol marks the start of URL parameters.
âš™ï¸ Each parameter is a propertyâ€“value pair:
Left side = property name (key)
Right side = value

ğŸ§ª Example
https://myshop.com/track?orderId=12345&productId=abc789
Symbol	Part	Meaning
ğŸŒ	Base URL	https://myshop.com/track â€” the page
â“	Start of params	? â€” says â€œI'm adding parameters nowâ€
ğŸ·ï¸	Parameter 1	orderId=12345 â€” key: orderId, value: 12345
â•	Separator	& â€” separates multiple parameters
ğŸ	Parameter 2	productId=abc789 â€” key: productId, value: abc789

âœ… Benefits of URL Parameters:
ğŸ§© Let you pass specific data without changing the page.
ğŸ›°ï¸ Can be read by JavaScript to customize the page.
ğŸ› ï¸ Useful for tracking, filters, pagination, etc.

URL parameters = search parameters like YT search
URL parameters lets us save different data in each URL 
--------------------------------------------------------
CORS- Cross Origin Resource Sharing
ğŸŒ CORS â€” Cross-Origin Resource Sharing
ğŸ”’ By default:
A webpage (from ğŸ”µ origin A) canâ€™t fetch data from a ğŸ”´ different origin B (different domain, port, or protocol).

âš ï¸ Example:
// Your site:
https://your-frontend.com   ğŸ”µ

// API:
https://api-server.com      ğŸ”´
If ğŸ”µ tries to fetch() from ğŸ”´, the browser blocks it âŒ unless ğŸ”´ explicitly says:
Access-Control-Allow-Origin: https://your-frontend.com
âœ… Thatâ€™s CORS â€” the server (ğŸ”´) must grant permission.
âœ… Use Case:
Frontend (React/Vue/etc.) â†’ Backend API
CORS lets the server safely allow cross-origin requests

